pop.predict <- function(end.year=2100, start.year=1950, present.year=2010, wpp.year=2010,
						countries=NULL, output.dir = file.path(getwd(), "bayesPop.output"),
						inputs=list(
							popM=NULL,
							popF=NULL,
							mxM=NULL,
							mxF=NULL,
							srb=NULL,
							pasfr=NULL,
							mig.type=NULL,
							migM=NULL,
							migF=NULL,										e0M.file=NULL, 
							e0F.file=NULL, 
							tfr.file=NULL,
							e0M.sim.dir=NULL, 
							e0F.sim.dir=NULL, 
							tfr.sim.dir=NULL	
						), nr.traj = 1000, 
						replace.output=FALSE, 
						verbose=TRUE) {
	prediction.exist <- FALSE
	ages=seq(0, by=5, length=27)
	if(is.null(countries)) inp <- load.inputs(inputs, start.year, present.year, end.year, wpp.year)
	else {
		if(has.pop.prediction(output.dir) && !replace.output) {
			pred <- get.pop.prediction(output.dir)
			inp <- pred$inputs
			nr.traj <- pred$nr.traj
			ages <- pred$ages
			prediction.exist <- TRUE
		} else inp <- load.inputs(inputs, start.year, present.year, end.year, wpp.year)
	}
	nages <- length(ages)
	nest <- length(inp$estim.years)
	outdir <- file.path(output.dir, 'predictions')
	if(!prediction.exist) {
		if(!replace.output && has.pop.prediction(sim.dir=output.dir))
			stop('Prediction in ', outdir,
			' already exists.\nSet replace.output=TRUE if you want to overwrite existing projections.')
		unlink(outdir, recursive=TRUE)
	} else {
		PIs_cqp <- pred$quantiles
		quantM <- pred$quatilesM
		quantF <- pred$quatilesF
		mean_sd <- pred$traj.mean.sd
		mean_sdM <- pred$traj.mean.sdM
		mean_sdF <- pred$traj.mean.sdF
		quantMage <- pred$quantilesMage
		quantFage <- pred$quantilesFage
	}
	prediction.file <- file.path(outdir, 'prediction.rda')
	
	data(LOCATIONS)
	if(!is.null(countries) && is.na(countries[1])) { # all countries that are not included in the existing prediction
		all.countries <- unique(inp$POPm0[,'country_code'])
		country.codes <- if(!prediction.exist) all.countries
						else all.countries[!is.element(all.countries, pred$countries[,'code'])]
	} else {
		if(!is.null(countries)) {
			if (is.character(countries)) { # at least one of the codes is a character string
				for (icountry in 1:length(countries)) {
					if (is.character(countries[icountry])) {
						country.idx <- which(LOCATIONS[,'name'] == countries[icountry])
						if(length(country.idx) > 0)
							countries[icountry] <- LOCATIONS[country.idx,'country_code']
					}
				}
			}
			country.codes <- countries
		} else
			country.codes <- unique(inp$POPm0[,'country_code'])
	}
			
	ncountries <- length(country.codes)
	nr_project <- length(inp$proj.years)
	if(!file.exists(outdir)) 
		dir.create(outdir, recursive=TRUE)
		
	quantiles.to.keep <- c(0,0.025,0.05,0.1,0.2,0.25,0.3,0.4,0.5,0.6,0.7,0.75,0.8,0.9,0.95,0.975,1)
	PIs_cqp <- quantM <- quantF <- array(NA, c(ncountries, length(quantiles.to.keep), nr_project+1),
						dimnames=list(NULL, quantiles.to.keep, c(inp$estim.years[nest], inp$proj.years)))
	quantMage <- quantFage <- array(NA, c(ncountries, nages, length(quantiles.to.keep), nr_project+1),
						dimnames=list(NULL, ages, quantiles.to.keep, c(inp$estim.years[nest], inp$proj.years)))
	mean_sd <- mean_sdM <- mean_sdF <- array(NA, c(ncountries, 2, nr_project+1))
	country.idx.proj <- c()
	cidx <- 0
	bayesPop.prediction <- NULL
	for(country in country.codes) {
		country.idx <- which(LOCATIONS[,'country_code'] == country)
		if(length(country.idx) == 0) {
			warning('Country ', country, ' not found in the LOCATIONS dataset.')
			next
		}
		if(verbose)
			cat('\nProcessing country ', country, ' -- ', as.character(LOCATIONS[country.idx,'name']))
		# Extract the country-specific stuff from the inputs
		inpc <- get.country.inputs(country, inp, nr.traj, LOCATIONS[country.idx,'name'])
		if(is.null(inpc)) next
		nr.traj <- ncol(inpc$TFRpred)		
		if(verbose)
			cat(' (', nr.traj, ' trajectories )')
		
		npred <- min(nrow(inpc$TFRpred), nr_project)
		#npred <- 19
		totp <- matrix(NA, nrow=npred+1, ncol=nr.traj)
		totpm <- totpf <- array(NA, dim=c(27, npred+1, nr.traj))
		debug <- FALSE
		MxKan <- runKannisto(nest, inpc)
		npasfr <- nrow(inpc$PASFR)			
		for(itraj in 1:nr.traj) {
			asfr <- inpc$PASFR/100.
			for(i in 1:npasfr) asfr[i,] <- inpc$TFRpred[,itraj] * asfr[i,]
			#debug <- country == 478
			sr <- modifiedLC(nest, npred, MxKan, inpc$e0Mpred[,itraj], 
									inpc$e0Fpred[,itraj], verbose=verbose, debug=debug)
			popres <- StoPopProj(npred, inpc, sr, asfr, inpc$MIGtype, LOCATIONS[country.idx,'name'])
			totp[,itraj] <- popres$totpop
			totpm[,,itraj] <- popres$mpop
			totpf[,,itraj] <- popres$fpop
		}
		country.idx.proj <- c(country.idx.proj, country.idx)
		cidx <- cidx + 1
		save(totp, totpm, totpf, file = file.path(outdir, paste('totpop_country', country, '.rda', sep='')))
		PIs_cqp[cidx,,] = apply(totp, 1, quantile, quantiles.to.keep, na.rm = TRUE)
		mean_sd[cidx,1,] <- apply(totp, 1, mean, na.rm = TRUE)
		mean_sd[cidx,2,] = apply(totp, 1, sd, na.rm = TRUE)
		for (i in 1:nages) 
			quantMage[cidx,i,,] <- apply(totpm[i,,], 1, quantile, quantiles.to.keep, na.rm = TRUE)
		for (i in 1:nages)
			quantFage[cidx,i,,] = apply(totpf[i,,], 1, quantile, quantiles.to.keep, na.rm = TRUE)
		stotpm <- colSums(totpm)
		quantM[cidx,,] = apply(stotpm, 1, quantile, quantiles.to.keep, na.rm = TRUE)
		mean_sdM[cidx,1,] <- apply(stotpm, 1, mean, na.rm = TRUE)
		mean_sdM[cidx,2,] = apply(stotpm, 1, sd, na.rm = TRUE)
		stotpf <- colSums(totpf)
		quantF[cidx,,] = apply(stotpf, 1, quantile, quantiles.to.keep, na.rm = TRUE)
		mean_sdF[cidx,1,] <- apply(stotpf, 1, mean, na.rm = TRUE)
		mean_sdF[cidx,2,] = apply(stotpf, 1, sd, na.rm = TRUE)
		
		#save updated meta file
		country.row <- LOCATIONS[country.idx,c('country_code', 'name')]
		colnames(country.row) <- c('code', 'name')
		if(is.null(bayesPop.prediction)) {
			if(prediction.exist) 
				bayesPop.prediction <- pred
			else {
				bayesPop.prediction <- structure(list(output.directory=outdir,
							nr.traj = nr.traj,	
							# assign empty arrays
							quantiles = PIs_cqp[c(),,,drop=FALSE],
               				traj.mean.sd = mean_sd[c(),,,drop=FALSE],
               				quantilesM = quantM[c(),,,drop=FALSE], 
               				traj.mean.sdM = mean_sdM[c(),,,drop=FALSE],
               				quantilesF = quantF[c(),,,drop=FALSE], 
               				traj.mean.sdF = mean_sdF[c(),,,drop=FALSE],
               				quantilesMage = quantMage[c(),,,,drop=FALSE], 
               				quantilesFage = quantFage[c(),,,,drop=FALSE],
               				estim.years=inp$estim.years, 
               				proj.years=c(inp$estim.years[length(inp$estim.years)], 
               									inp$proj.years), # includes present period
			   				inputs = inp,
			   				countries=matrix(NA, nrow=0, ncol=2, dimnames=list(NULL, c('code', 'name'))),
			   				ages=ages), class='bayesPop.prediction')
			}
		}
		idx.in.pred.overwrite <- which(bayesPop.prediction$countries[,'code'] == country)
		if(any(idx.in.pred.overwrite)) {
			bayesPop.prediction$quantiles[idx.in.pred.overwrite,,] <- PIs_cqp[cidx,,,drop=FALSE]
			bayesPop.prediction$traj.mean.sd[idx.in.pred.overwrite,,] <- mean_sd[cidx,,,drop=FALSE]
			bayesPop.prediction$traj.mean.sdM[idx.in.pred.overwrite,,] <- mean_sdM[cidx,,,drop=FALSE]
			bayesPop.prediction$traj.mean.sdF[idx.in.pred.overwrite,,] <- mean_sdF[cidx,,,drop=FALSE]
			bayesPop.prediction$quantilesM[idx.in.pred.overwrite,,] <- quantM[cidx,,,drop=FALSE]
			bayesPop.prediction$quantilesF[idx.in.pred.overwrite,,] <- quantF[cidx,,,drop=FALSE]
			bayesPop.prediction$quantilesMage[idx.in.pred.overwrite,,,] <- quantMage[cidx,,,,drop=FALSE]
			bayesPop.prediction$quantilesFage[idx.in.pred.overwrite,,,] <- quantFage[cidx,,,,drop=FALSE]
		} else { 
			bayesPop.prediction$quantiles <- abind(bayesPop.prediction$quantiles, 
												PIs_cqp[cidx,,,drop=FALSE], along=1)
			bayesPop.prediction$traj.mean.sd <- abind(bayesPop.prediction$traj.mean.sd, 
												mean_sd[cidx,,,drop=FALSE], along=1)
			bayesPop.prediction$traj.mean.sdM <- abind(bayesPop.prediction$traj.mean.sdM, 
												mean_sdM[cidx,,,drop=FALSE], along=1)
			bayesPop.prediction$traj.mean.sdF <- abind(bayesPop.prediction$traj.mean.sdF, 
												mean_sdF[cidx,,,drop=FALSE], along=1)
			bayesPop.prediction$quantilesM <- abind(bayesPop.prediction$quantilesM, 
												quantM[cidx,,,drop=FALSE], along=1)
			bayesPop.prediction$quantilesF <- abind(bayesPop.prediction$quantilesF, 
												quantF[cidx,,,drop=FALSE], along=1)
			bayesPop.prediction$quantilesMage <- abind(bayesPop.prediction$quantilesMage, 
												quantMage[cidx,,,,drop=FALSE], along=1)
			bayesPop.prediction$quantilesFage <- abind(bayesPop.prediction$quantilesFage, 
												quantFage[cidx,,,,drop=FALSE], along=1)
			bayesPop.prediction$countries <- rbind(bayesPop.prediction$countries, country.row)
		}
		save(bayesPop.prediction, file=prediction.file)
	}			   
	cat('\nPrediction stored into', outdir, '\n')
	invisible(bayesPop.prediction)
}

read.pop.file <- function(file) 
	return(read.delim(file=file, comment.char='#', check.names=FALSE))
	
read.bayesPop.file <- function(file)
	return(read.pop.file(file.path(.find.package("bayesPop"), "data", file)))

load.inputs <- function(inputs, start.year, present.year, end.year, wpp.year) {
	# Get initial population counts
	if(is.null(inputs$popM)) 
		POPm0 <- read.bayesPop.file(paste('PopByAgeMale', wpp.year, '.txt', sep=''))	else POPm0 <- read.pop.file(inputs$popM)
	if(!is.element(as.character(present.year), colnames(POPm0))) {
		num.columns <- grep('^[0-9]{4}$', colnames(POPm0), value=TRUE) # values of year-columns
		stop('Wrong present.year. ', present.year, ' not available in the popM file.\nAvailable years: ',
				num.columns)
	}
	POPm0 <- POPm0[,c('country_code', 'age', present.year)]
	if(is.null(inputs$popF)) 
		POPf0 <- read.bayesPop.file(paste('PopByAgeFemale', wpp.year, '.txt', sep=''))
	else POPf0 <- read.pop.file(inputs$popF)
	POPf0 <- POPf0[,c('country_code', 'age', present.year)]
	if(!is.element(as.character(present.year), colnames(POPf0))) {
		num.columns <- grep('^[0-9]{4}.[0-9]{4}$', colnames(POPf0), value=TRUE) # values of year-columns
		stop('Wrong present.year. ', present.year, ' not available in the popF file.\nAvailable years: ',
				num.columns)
	}
	# Get death rates
	if(is.null(inputs$mxM)) 
		MXm <- read.bayesPop.file(paste('ASMRMale', wpp.year, '.txt', sep=''))
	else MXm <- read.pop.file(inputs$mxM)
	names.MXm.data <- names(MXm)
	num.columns <- grep('^[0-9]{4}.[0-9]{4}$', names.MXm.data) # index of year-columns
	cols.starty <- as.integer(substr(names.MXm.data[num.columns], 1,4))
    cols.endy <- as.integer(substr(names.MXm.data[num.columns], 6,9))
	start.index <- which((cols.starty <= start.year) & (cols.endy > start.year))
	present.index <- which((cols.endy >= present.year) & (cols.starty < present.year))
	estim.periods <- names.MXm.data[num.columns[start.index:present.index]]
	MXm <- MXm[,c('country_code', 'age', estim.periods)]
	mid.est.years <- cols.starty[start.index:present.index] + 3
	if(is.null(inputs$mxF)) 
		MXf <- read.bayesPop.file(paste('ASMRFemale', wpp.year, '.txt', sep=''))
	else MXf <- read.pop.file(inputs$mxF)
	MXf <- MXf[,c('country_code', 'age', estim.periods)]
	
	# Get sex ratio at birth
	if(is.null(inputs$srb)) 
		SRB <- read.bayesPop.file(paste('SexRatioAtBirth', wpp.year, '.txt', sep=''))
	else SRB <- read.pop.file(inputs$srb)
	names.SRB.data <- names(SRB)
	num.columns <- grep('^[0-9]{4}.[0-9]{4}$', names.SRB.data) # index of year-columns
	cols.starty <- as.integer(substr(names.SRB.data[num.columns], 1,4))
    cols.endy <- as.integer(substr(names.SRB.data[num.columns], 6,9))
	start.index <- which((cols.starty <= present.year) & (cols.endy > present.year))
	end.index <- which((cols.endy >= end.year) & (cols.starty < end.year))
	if(length(end.index) == 0) {
		end.index <- length(num.columns)
		warning('Data for SexRatioAtBirth not available for all projection periods.\nLast projection period set to ', 
					names.SRB.data[num.columns[end.index]])
	}
	proj.periods <- names.SRB.data[num.columns[start.index:end.index]]
	SRB <- SRB[,c('country_code', proj.periods)]
	mid.proj.years <- cols.starty[start.index:end.index] + 3
	
	# Get percentage age-specific fertility rate
	if(is.null(inputs$pasfr)) 
		PASFR <- read.bayesPop.file(paste('PercentASFR', wpp.year, '.txt', sep=''))
	else PASFR <- read.pop.file(inputs$pasfr)
	PASFR <- PASFR[,c('country_code', 'age', proj.periods)]
	
	# Get migration type and base year
	if(is.null(inputs$mig.type)) 
		MIGtype <- read.bayesPop.file(paste('vwBaseYear', wpp.year, '.txt', sep=''))
	else MIGtype <- read.pop.file(inputs$mig.type)
	MIGtype <- MIGtype[,c('country_code', 'ProjFirstYear', 'MigCode')]
	# Get age-specific migration
	if(is.null(inputs$migM)) 
		MIGm <- read.bayesPop.file(paste('MigByAgeMale', wpp.year, '.txt', sep=''))
	else MIGm <- read.pop.file(inputs$migM)
	MIGm <- MIGm[,c('country_code', 'age', proj.periods)]
	if(is.null(inputs$migF))
		MIGf <- read.bayesPop.file(paste('MigByAgeFemale', wpp.year, '.txt', sep=''))
	else MIGf <- read.pop.file(inputs$migF)
	MIGf <- MIGf[,c('country_code', 'age', proj.periods)]
	
	# Get life expectancy
	if(!is.null(inputs$e0M.sim.dir)) # male
		e0Mpred <- get.e0.prediction(inputs$e0M.sim.dir, mcmc.dir=NA)
	else {
		file.name <- if(!is.null(inputs$e0M.file)) inputs$e0M.file 
					else file.path(.find.package("bayesPop"), "ex-data", 
							paste('e0Mwpp', wpp.year, '.csv', sep=''))
		e0Mpred <- read.csv(file=file.name, comment.char='#', check.names=FALSE)
		e0Mpred <- e0Mpred[,c('LocID', 'Year', 'e0')]
		colnames(e0Mpred) <- c('country_code', 'year', 'value')
	} 
	if(!is.null(inputs$e0F.sim.dir))  # female
		e0Fpred <- get.e0.prediction(inputs$e0F.sim.dir, mcmc.dir=NA)
	else {
		file.name <- if(!is.null(inputs$e0F.file)) inputs$e0F.file
					else file.path(.find.package("bayesPop"), "ex-data", 
							paste('e0Fwpp', wpp.year, '.csv', sep=''))
		e0Fpred <- read.csv(file=file.name, comment.char='#', check.names=FALSE)
		e0Fpred <- e0Fpred[,c('LocID', 'Year', 'e0')]
		colnames(e0Fpred) <- c('country_code', 'year', 'value')
	} 
		
	# Get TFR
	if(!is.null(inputs$tfr.sim.dir)) 
		TFRpred <- get.tfr.prediction(inputs$tfr.sim.dir, mcmc.dir=NA)
	else {
		file.name <- if(!is.null(inputs$tfr.file)) inputs$tfr.file
					else file.path(.find.package("bayesPop"), "ex-data", 
							paste('TFRwpp', wpp.year, '.csv', sep=''))
		TFRpred <- read.csv(file=file.name, comment.char='#', check.names=FALSE)
		TFRpred <- TFRpred[,c('LocID', 'Year', 'TF')]
		colnames(TFRpred) <- c('country_code', 'year', 'value')
	} 
	return(list(POPm0=POPm0, POPf0=POPf0, MXm=MXm, MXf=MXf, SRB=SRB,
				PASFR=PASFR, MIGtype=MIGtype, MIGm=MIGm, MIGf=MIGf,
				e0Mpred=e0Mpred, e0Fpred=e0Fpred, TFRpred=TFRpred, 
				estim.years=mid.est.years, proj.years=mid.proj.years))
}

get.country.inputs <- function(country, inputs, nr.traj, country.name) {
	inpc <- list()
	for(par in c('POPm0', 'POPf0', 'MXm', 'MXf', 'SRB',
						'PASFR', 'MIGtype', 'MIGm', 'MIGf')) {
		idx <- inputs[[par]][,'country_code'] == country
		inpc[[par]] <- inputs[[par]][idx,]
		inpc[[par]] <- as.matrix(inpc[[par]][, !is.element(colnames(inpc[[par]]), 
							c('country_code', 'age'))])
	}
	inpc[['MIGBaseYear']] <- inpc[['MIGtype']][,'ProjFirstYear']
	inpc[['MIGtype']] <- inpc[['MIGtype']][,'MigCode']
	for(par in c('TFRpred', 'e0Mpred', 'e0Fpred')) {
		if (is.data.frame(inputs[[par]])) {
			idx <- inputs[[par]][,'country_code'] == country & is.element(inputs[[par]][,'year'], inputs$proj.years)
			inpc[[par]] <- inputs[[par]][idx,]
			inpc[[par]] <- matrix(inpc[[par]][, 'value'], nrow=length(inputs$proj.years))
			rownames(inpc[[par]]) <- as.character(inputs$proj.years)
		}
	}
	if(is.null(inpc$e0Mpred)) {
		inpc$e0Mpred <- get.e0.trajectories(inputs$e0Mpred, country)
		if(is.null(inpc$e0Mpred)) {
			warning('No male e0 trajectories for ', country.name, 
					'. No population projection generated.')
			return(NULL)	
		}
	}
	if(is.null(inpc$e0Fpred)) {
		inpc$e0Fpred <- get.e0.trajectories(inputs$e0Fpred, country)
		if(is.null(inpc$e0Fpred)) {
			warning('No female e0 trajectories for ', country.name, 
					'. No population projection generated.')
			return(NULL)
		}
	}
	if(is.null(inpc$TFRpred)) {
		inpc$TFRpred <- get.tfr.trajectories(inputs$TFRpred, country)
		if(is.null(inpc$TFRpred)) {
			warning('No TFR trajectories for ', country.name, 
					'. No population projection generated.')
			return(NULL)	
		}
	}
	indices <- list()
	indices$e0Mpred <- get.traj.index(nr.traj, inpc$e0Mpred)
	indices$e0Fpred <- if (ncol(inpc$e0Mpred) != ncol(inpc$e0Fpred)) get.traj.index(nr.traj, inpc$e0Fpred)
					else indices$e0Mpred
	indices$TFRpred <- get.traj.index(nr.traj, inpc$TFRpred)
	nr.traj <- min(length(indices$e0Mpred), length(indices$e0Fpred), length(indices$TFRpred))
	for (par in c('TFRpred', 'e0Mpred', 'e0Fpred')) {
		if(length(indices[[par]]) != nr.traj)
			indices[[par]] <- get.traj.index(nr.traj, inpc[[par]])
	}
			
	if(length(indices$TFRpred) != length(indices$e0Mpred) || length(indices$e0Mpred) != length(indices$e0Fpred)) {
		warning('Mismatch in number of trajectories of TFR and/or life expactancy for ', 
						country.name, '. No population projection generated.')
		return(NULL)	
	}
	for (par in c('TFRpred', 'e0Mpred', 'e0Fpred')) {
		inpc[[par]] <- inpc[[par]][,indices[[par]]]
		inpc[[par]] <- inpc[[par]][as.character(inputs$proj.years),]
	}
	return(inpc)
}

get.traj.index <- function(nr.traj, traj) {
	ncoltraj <- ncol(traj)
	if(nr.traj >= ncoltraj) return(1:ncoltraj)
	return(seq(1, ncoltraj, length=nr.traj))
}

runKannisto <- function(nest, inputs) {
	# extend mx, get LC ax,bx,k1
	mxMKan <- c(KannistoAxBx(nest, inputs$MXm, inputs$MIGBaseYear), sex=1)
	mxFKan <- c(KannistoAxBx(nest, inputs$MXf, inputs$MIGBaseYear), sex=2)
	bx <- 0.5 * (mxMKan$bx + mxFKan$bx)
	bx.lim=c(min(bx[bx>0]), max(bx[bx>0]))
	lmin <- -12
	lmax <- 0
	machine.max <- log(.Machine$double.xmax)
	machine.min <- log(.Machine$double.xmin)
	klM <- min((lmax - min(mxMKan$ax))/bx.lim[2], machine.max)
	klF <- min((lmax - min(mxFKan$ax))/bx.lim[2], machine.max)
	kuM <- max((lmin - max(mxMKan$ax))/bx.lim[1], machine.min)
	kuF <- max((lmin - max(mxFKan$ax))/bx.lim[1], machine.min)

	return(list(male=mxMKan, female=mxFKan, 
				bx=bx, kl=c(klM, klF), ku=c(kuM, kuF)))
}

modifiedLC <- function (nest, npred, mxKan, eopm, eopf, verbose=FALSE, debug=FALSE) {
	eop  <- list(eopm, eopf)
    # Using combined bx, This differs from ModifiedLC0!    
    sr <- list(matrix(0, nrow=27, ncol=npred), matrix(0, nrow=27, ncol=npred))
    sr1 <- list(matrix(0, nrow=27, ncol=npred), matrix(0, nrow=27, ncol=npred))
    #Get the projected kt from eo, and make projection of Mx
    for (mxYKan in list(mxKan$male, mxKan$female)) { # iterate over male and female
    	res <- .C("LC", as.integer(npred), as.integer(mxYKan$sex), as.numeric(mxYKan$ax), as.numeric(mxYKan$bx), 
			as.numeric(eop[[mxYKan$sex]]), Kl=as.numeric(mxKan$kl[[mxYKan$sex]]), Ku=as.numeric(mxKan$ku[[mxYKan$sex]]), 
			LLm = rep(0, 27), Sr=as.numeric(sr[[mxYKan$sex]]))
		sr[[mxYKan$sex]] <- matrix(res$Sr, nrow=27)
		#print('\nR code')
#    	for(i in 1:npred) {	
#    		LLm <- LCEoKtmod.bak(mxYKan$sex, mxYKan$ax, mxKan$bx, eop[[mxYKan$sex]][i], 
#    						mxKan$kl[[mxYKan$sex]], mxKan$ku[[mxYKan$sex]], debug=debug)
#    		sr1[[mxYKan$sex]][,i] <- LifeTB.sx(LLm)
#    		#print(LLm)
#    	}
    	#print('')
    	#print('sr')
    	#print(sr[[mxYKan$sex]])
    	#print('sr1')
    	#print(sr1[[mxYKan$sex]])

    }
	return(sr)    
}

KannistoAxBx <- function(ne, mx, yb)  {
	# Extending mx to age 130 using Kannisto model and mx 80-99, OLS
	# ne is the number of projections
	Mxe <- as.matrix(mx)
	Mxe <- rbind(Mxe, 
			matrix(NA, nrow=28-nrow(mx), ncol=ncol(mx)))

	k <- 22:28
	h <- 100 + 5 * (0:6)
	hminus80 <- h - 80
	lmxr <- log(mx[18:21, 1:ne] / (1 - mx[18:21, 1:ne]))
	Xm1 <- apply(lmxr, 2, sum)
	Xm2 <- apply((5 * (1:4) - 5) * lmxr, 2, sum)
	for(j in 1:ne) {
		aam = exp((350 * Xm1[j] - 30 * Xm2[j]) / 500) # 500 = 4 * 350 - 30^2
		bbm = (Xm1[j] - 4 * log(aam)) / 30
		# Ages 100-105, ..., 130+
		expterm <- aam * exp(bbm * (hminus80))	
		Mxe[k, j] =  expterm / (1 + expterm)
	}
    lMxe <- log(Mxe)
    
	#Get Lee-Cater Ax and Bx
	if(yb > 1980) yb <- 1980
	ns <- (yb - 1950) / 5 + 1
    
    x1 <- apply(lMxe[,ns:ne], 1, sum)
    ax <- x1 / (ne - ns + 1)

	kt <- rep(NA, ne)
	kt[ns:ne] = apply(lMxe[,ns:ne], 2, sum) - sum(ax)
    
	x2 <- sum(kt[ns:ne]*kt[ns:ne])
	x1 <- rep(NA, nrow(Mxe))
	for (i in 1:nrow(Mxe)) 
		x1[i] <- sum((lMxe[i,ns:ne]-ax[i])*kt[ns:ne])
	bx <- x1/x2
	negbx <- which(bx <= 0)
	lnegbx <- length(negbx)
	if(lnegbx > 0 && negbx[1] == 1) {
		#warning('First value of bx is negative.', immediate. = TRUE)
		#stop('')
		#posbx <- which(bx > 0)[1]
		bx[1] <- 0
		negbx <- if(lnegbx > 1) negbx[2:lnegbx] else c()
		lnegbx <- length(negbx)
	}
	while(lnegbx > 0) {
		bx[negbx] <- 0.5 * bx[negbx-1]
		negbx <- which(bx < 0)
		lnegbx <- length(negbx)
	}
       
	for (i in 1:27) { # ?
		if (bx[29 - i] == 0) bx[29 - i] <- bx[29 - i - 1]
	}
    bx[19:28] <- bx[18]   # bx(80) is used for all older ages to fit large Eo

	return(list(mx=mx, ax=ax, bx=bx, k0=kt[ne], d1=(kt[ne] - kt[ns]) / (ne - ns + 1)))
}

LCEoKt <- function(sex, ax, bx, eop, k1, debug=FALSE) {
	# The idea of the LCEoKt comes from Thomas Buettner
	mxi <- exp(ax + bx*k1)
	LT <- LifeTB(sex, mxi)
	if(debug) cat('\neop: ', eop, '; ', LT$eo, '\n')
	# Making the bracket, [kl,ku], to include the target eop
	if(LT$eo <= eop) {
		kl <- k1 # the lower bound
        #Find the upper bound
        if(LT$eo == eop) ku <- k1-2
		n <- 0
		while(LT$eo < eop) {
			n <- n + 1
			ku <- k1 - 2^n # the updated upper bound
			mxi <- exp(ax + bx*ku)
			LT <- LifeTB(sex, mxi)
			if(debug) cat('A. ', paste(n, kl, ku, LT$eo, sep=', '),'\n')
		}
	} else {
		ku <- k1 # the upper bound
		# Find the lower bound
		n <- 0
		while(LT$eo > eop) {
			n <- n + 1
			kl <- k1 + 2^n # the updated lower bound
			mxi <- exp(ax + bx*kl)
			LT <- LifeTB(sex, mxi)
			if(debug) cat('B. ', paste(n, kl, ku, LT$eo, sep=', '),'\n')
		}
	}
	# Reduce the bracket
	k2 <- ku
	while(abs(LT$eo - eop) > 0.01) {
		k2 <- 0.5 * (kl + ku)
		mxi <- exp(ax + bx*k2)
		LT <- LifeTB(sex, mxi)
		if(debug) cat('C. ', paste(n, k2, kl, ku, LT$eo, sep=', '),'\n')
		if(LT$eo < eop) kl <- k2
		else ku <- k2
	}
	return(k2)
}

LCEoKtmod <- function(sex, ax, bx, eop, kl, ku, debug=FALSE) {
	res <- .C("LCEoKtC", as.integer(sex), as.numeric(ax), as.numeric(bx), 
			as.numeric(eop), Kl=as.numeric(kl), Ku=as.numeric(ku), LLm = rep(0, 27))
	return(res$LLm)
}

LCEoKtmod.bak <- function(sex, ax, bx, eop, kl, ku, debug=FALSE) {
	# The idea of the LCEoKtmod comes from Adrian Raftery
	# check if the eop lies outside of the bounds
	LTl <- LifeTB(sex, exp(ax + bx*kl))
	if(eop < sum(LTl)) return(LTl)
	LTu <- LifeTB(sex, exp(ax + bx*ku))
	if(eop > sum(LTu)) return(LTu)
	#if(debug) {
	#	cat('A. ', paste(kl, ku, eop, LTl$eo, LTu$eo, sep=', '),'\n')
	#}
	# Bi-section method
	k2 <- 0.5 * (kl + ku)
	LLm <- LifeTB(sex, exp(ax + bx*k2))
	LT.eo <- sum(LLm)
	#if(debug) cat('B. ', paste(k2, LT$eo, sep=', '),'\n')
#	stop('')
	while(abs(LT.eo - eop) > 0.01) {
		if(LT.eo < eop) kl <- k2
		else ku <- k2
		k2 <- 0.5 * (kl + ku)
		LLm <- LifeTB(sex, exp(ax + bx*k2))
		LT.eo <- sum(LLm)
	#	if(debug) cat('C. ', paste(kl, ku, LT$eo, eop, k2, sep=', '),'\n')
	}
	#print(c(k2, eop, LT.eo))
	return(LLm)
}

LifeTB.eo <- function(sex, mxm) {
	return(sum(LifeTB(sex, mxm)))
}

LifeTB.sx <- function(LLm) {
	# Survival Ratios
    sx <- rep(0, 27)
    sx[1] = LLm[1] / 5
    LLmneq0 <- which(LLm[1:25]!=0)
    sx[LLmneq0+1] <- LLm[LLmneq0+1]/LLm[LLmneq0]

	# Last age group
	sx[27] <- if(LLm[26] == 0) 0 else LLm[27] / (LLm[26] + LLm[27])
	if(sx[27] > sx[26])  sx[27] = sx[26]
	return(sx)
}

LifeTB <- function(sex, mxm) {
	.C("LifeTableC", as.integer(sex), as.numeric(mxm), LLm = rep(0, 27))$LLm
}

LifeTB.bak <- function(sex, mxm) {
	# Life table computing
    # Age0-4 (a0 and a1)
    if(sex > 1) {# female
		am <- if (mxm[1] < 0.107) c(0.053 + 2.8 * mxm[1], 1.522 - 1.518 * mxm[1])
				else c(0.35, 1.361)
	} else { # male
		am <- if (mxm[1] < 0.107) c(0.045 + 2.684 * mxm[1], 1.651 - 2.816 * mxm[1])
				else c(0.33, 1.352)
	}
	lm <- rep(NA, 28)
	LLm <- rep(NA, 27)
	lm[1:3] <- c(1, 1 - mxm[1] / (1 + (1 - am[1]) * mxm[1]), (1 - 4 * mxm[2] / (1 + (4 - am[2]) * mxm[2])))
	lm[3] <- lm[2] * lm[3]
	LLm[1] = (lm[2] + am[1] * (1 - lm[2])) + (4 * lm[3] + am[2] * (lm[2] - lm[3])) # Life table male 4L0
    
    # Age 5-9, .... 95-99
    # Greville formula used in Mortpak and UN MLT (1982)
    i2to20 <- 2:20
    i3to21 <- 3:21
    i4to22 <- 4:22
    am <- c(am, 2.5 - (25 / 12.0) * (mxm[i3to21] - 0.1 * log(mxm[i4to22] / mxm[i2to20])))
    qmx <- 5 * mxm[i3to21] / (1 + (5 - am[i3to21]) * mxm[i3to21])
    oneminusqmx <- 1-qmx[1:19]
    for(i in i2to20) lm[i+2] <- lm[i+1] * oneminusqmx[i-1]
    LLm[i2to20] = 5 * lm[i4to22] + am[i3to21] * (lm[i3to21] - lm[i4to22])
    
    i21to26 <- 21:26
    i22to27 <- 22:27
    oneminusqmx <- 1 - (1 - exp(-5 * mxm[i22to27]))
	for(i in i21to26) lm[i+2] = lm[i+1] * oneminusqmx[i-20]  # Starts 104
	LLm[i21to26] = (lm[i22to27] - lm[23:28]) / mxm[i22to27]

    # Age 130+
	LLm[27] <- lm[28] / mxm[28] # Assuming Mx levels off at age 130
    return(LLm)
}

StoPopProj1 <- function(npred, inputs, sr, asfr, country.name) {
	popm <- popf <- matrix(NA, nrow=27, ncol=npred+1)	
	popm[,1] <- c(inputs$POPm0, rep(0, 6))
	popf[,1] <- c(inputs$POPf0, rep(0, 6))
	
	migm <- rbind(inputs$MIGm, matrix(0, nrow=6, ncol=ncol(inputs$MIGm), 
						dimnames=list(NULL, colnames(inputs$MIGm))))
	migf <- rbind(inputs$MIGf, matrix(0, nrow=6, ncol=ncol(inputs$MIGf),
						dimnames=list(NULL, colnames(inputs$MIGf))))
	totp <- c(sum(popm[,1]+popf[,1]), rep(NA, npred))
	
	# Population projection for one trajectory of TF
	for(j in 2:(npred+1)) {
		# Compute ages >=5
		popm[2:26,j] <- popm[1:25, j-1] * sr[[1]][2:26, j-1] + migm[2:26, j-1]
		popf[2:26,j] <- popf[1:25, j-1] * sr[[2]][2:26, j-1] + migf[2:26, j-1]
		#Age 100+
		popm[27,j] <- (popm[27, j-1] + popm[26, j-1]) * sr[[1]][27, j-1] + migm[27, j-1]
		popf[27,j] <- (popf[27, j-1] + popf[26, j-1]) * sr[[2]][27, j-1] + migf[27, j-1]
		
		# birth in 5-yrs
  		b <- sum(0.5 * (popf[4:10, j-1] + popf[4:10, j]) * asfr[1:7,j - 1])
	  	bm <- b * inputs$SRB[j - 1] / (1 + inputs$SRB[j - 1])
  		bf = b / (1 + inputs$SRB[j - 1])

 		popm[1, j] <- unlist(bm * sr[[1]][1, j - 1] + migm[1, j - 1])
 		popf[1, j] <- unlist(bf * sr[[2]][1, j - 1] + migf[1, j - 1])
 
 		if(any(popm[,j] < 0)) warnings('Negative male population for ', country.name)
		if(any(popf[,j] < 0)) warnings('Negative female population for ', country.name)

 		totp[j] <- sum(popm[,j]+popf[,j])
	}
	return(list(totpop=totp, mpop=popm, fpop=popf))
}

StoPopProj <- function(npred, inputs, sr, asfr, mig.type, country.name) {
	#Mig evenly in period
	popm <- popf <- matrix(0, nrow=27, ncol=npred+1)	
	popm[,1] <- c(inputs$POPm0, rep(0, 6))
	popf[,1] <- c(inputs$POPf0, rep(0, 6))
	totp <- c(sum(popm[,1]+popf[,1]), rep(0, npred))
	
	res <- .C("TotalPopProj", npred, as.numeric(as.matrix(inputs$MIGm)), 
		as.numeric(as.matrix(inputs$MIGf)), nrow(inputs$MIGm), ncol(inputs$MIGm), mig.type,
		srm=sr[[1]], srf=sr[[2]], asfr=as.numeric(as.matrix(asfr)), 
		srb=as.numeric(as.matrix(inputs$SRB)), popm=popm, popf=popf, totp=totp
		)
	
#	migm <- rbind(inputs$MIGm, matrix(0, nrow=6, ncol=ncol(inputs$MIGm), 
#						dimnames=list(NULL, colnames(inputs$MIGm))))
#	migf <- rbind(inputs$MIGf, matrix(0, nrow=6, ncol=ncol(inputs$MIGf),
#						dimnames=list(NULL, colnames(inputs$MIGf))))
#	
#	
#	
#	# Population projection for one trajectory of TF
#	for(j in 2:(npred+1)) {
#		# Compute ages >=5
#		popm[2:26,j] <- popm[1:25, j-1] * sr[[1]][2:26, j-1] + 0.5*(migm[2:26, j-1] + migm[1:25, j-1]*sr[[1]][2:26, j-1])
#		popf[2:26,j] <- popf[1:25, j-1] * sr[[2]][2:26, j-1] + 0.5*(migf[2:26, j-1] + migf[1:25, j-1]*sr[[2]][2:26, j-1])
#		#Age 100+
#		popm[27,j] <- (popm[27, j-1] + popm[26, j-1]) * sr[[1]][27, j-1] + migm[27, j-1]
#		popf[27,j] <- (popf[27, j-1] + popf[26, j-1]) * sr[[2]][27, j-1] + migf[27, j-1]
#		
#		# birth in 5-yrs
#  		b <- sum(0.5 * (popf[4:10, j-1] + popf[4:10, j]) * asfr[1:7,j - 1])
#	  	bm <- b * inputs$SRB[j - 1] / (1 + inputs$SRB[j - 1])
#  		bf = b / (1 + inputs$SRB[j - 1])
#
# 		popm[1, j] <- unlist(bm * sr[[1]][1, j - 1] + 0.5 * migm[1, j - 1])
# 		popf[1, j] <- unlist(bf * sr[[2]][1, j - 1] + 0.5 * migf[1, j - 1])
# 
# 		if(any(popm[,j] < 0)) warnings('Negative male population for ', country.name)
#		if(any(popf[,j] < 0)) warnings('Negative female population for ', country.name)
#
# 		totp[j] <- sum(popm[,j]+popf[,j])
#	}

 	if(any(res$popm < 0)) warnings('Negative male population for ', country.name)
	if(any(res$popf < 0)) warnings('Negative female population for ', country.name)

	return(list(totpop=res$totp, mpop=res$popm, fpop=res$popf))
}


StoPopProj2.bak <- function(npred, inputs, sr, asfr, country.name) {
	#Mig evenly in period
	popm <- popf <- matrix(0, nrow=27, ncol=npred+1)	
	popm[,1] <- c(inputs$POPm0, rep(0, 6))
	popf[,1] <- c(inputs$POPf0, rep(0, 6))
	totp <- c(sum(popm[,1]+popf[,1]), rep(0, npred))
	
	migm <- rbind(inputs$MIGm, matrix(0, nrow=6, ncol=ncol(inputs$MIGm), 
						dimnames=list(NULL, colnames(inputs$MIGm))))
	migf <- rbind(inputs$MIGf, matrix(0, nrow=6, ncol=ncol(inputs$MIGf),
						dimnames=list(NULL, colnames(inputs$MIGf))))
	
	# Population projection for one trajectory of TF
	for(j in 2:(npred+1)) {
		# Compute ages >=5
		popm[2:26,j] <- popm[1:25, j-1] * sr[[1]][2:26, j-1] + 0.5*(migm[2:26, j-1] + migm[1:25, j-1]*sr[[1]][2:26, j-1])
		popf[2:26,j] <- popf[1:25, j-1] * sr[[2]][2:26, j-1] + 0.5*(migf[2:26, j-1] + migf[1:25, j-1]*sr[[2]][2:26, j-1])
		#Age 100+
		popm[27,j] <- (popm[27, j-1] + popm[26, j-1]) * sr[[1]][27, j-1] + migm[27, j-1]
		popf[27,j] <- (popf[27, j-1] + popf[26, j-1]) * sr[[2]][27, j-1] + migf[27, j-1]
		
		# birth in 5-yrs
  		b <- sum(0.5 * (popf[4:10, j-1] + popf[4:10, j]) * asfr[1:7,j - 1])
	  	bm <- b * inputs$SRB[j - 1] / (1 + inputs$SRB[j - 1])
  		bf = b / (1 + inputs$SRB[j - 1])

 		popm[1, j] <- unlist(bm * sr[[1]][1, j - 1] + 0.5 * migm[1, j - 1])
 		popf[1, j] <- unlist(bf * sr[[2]][1, j - 1] + 0.5 * migf[1, j - 1])
 
 		if(any(popm[,j] < 0)) warnings('Negative male population for ', country.name)
		if(any(popf[,j] < 0)) warnings('Negative female population for ', country.name)

 		totp[j] <- sum(popm[,j]+popf[,j])
	}

	return(list(totpop=totp, mpop=popm, fpop=popf))
}
